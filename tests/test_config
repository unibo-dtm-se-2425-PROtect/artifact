import unittest
from unittest.mock import patch, MagicMock
import string
import hashlib

from code.config import checkConfig, config, generateDeviceSecret

#Checking CHECKCONFIG()
@patch ("code.config.dbconfig")
def test_checkConfig_schema_exists(mock_dbconfig):
    mock_db=MagicMock()
    mock_cursor=MagicMock()
    mock_cursor.fetchall.return_value=[("PROtect",)]
    mock_db.cursor.return_value=mock_cursor
    mock_dbconfig.return_value=mock_db

    assert checkConfig() is True #it testifies that in the current environment checkConfig() returns True without exceptions
                                 #and that the DB currently contains a schema named PROtect (returns True when the schema exists)
    mock_cursor.execute.assert_called_once() 

@patch ("code.config.dbconfig")
def test_checkConfig_schema_missing(mock_dbconfig):
    mock_db=MagicMock()
    mock_cursor=MagicMock()
    mock_cursor.fetchall.return_value=[]
    mock_db.cursor.return_value=mock_cursor
    mock_dbconfig.return_value=mock_db

    assert checkConfig() is False
 
#ASSERT allows simple comparisons, quick to read and easy to understand and it shows detailed info whether assert fails
# In this way we can avoid using plenty of different methods from the library 

#Checking GENERATEDEVICESECRET()
def test_generateDeviceSecret_length():
    secret=generateDeviceSecret(15)
    assert len(secret)==15

def test_generateDeviceSecret_defaukt_length():
    secret=generateDeviceSecret()
    assert len(secret)==10

def test_generateDeviceSecret_characters(): 
    secret=generateDeviceSecret(50)
    allowed_chars=set(string.ascii_uppercase+string.digits)
    assert all(c in allowed_chars for c in secret)

def test_generateDeviceSecret_randomness():
    secrets={generateDeviceSecret(20) for i in range(100)}
    assert len(secrets) > 90 
    #generates 100 random secrets and expects at least 90 to be unique so that randomness is not broken


#Checking CONFIG()
